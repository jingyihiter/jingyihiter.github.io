<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on JingYi-Blog</title>
    <link>https://jingyihiter.github.io/post/</link>
    <description>Recent content in Posts on JingYi-Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 11 Dec 2017 21:40:07 +0800</lastBuildDate>
    <atom:link href="https://jingyihiter.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>survey_chatbot</title>
      <link>https://jingyihiter.github.io/2017/12/11/survey_chatbot</link>
      <pubDate>Mon, 11 Dec 2017 21:40:07 +0800</pubDate>
      
      <guid>https://jingyihiter.github.io/2017/12/11/survey_chatbot</guid>
      <description>

&lt;p&gt;闲聊机器人调研&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Q:闲聊机器人现如今主要用了哪些技术？分为哪些模块？&lt;/p&gt;

&lt;h1 id=&#34;1-聊天机器人系统:5c282e2caebe9b19eac140714253a324&#34;&gt;1、聊天机器人系统&lt;/h1&gt;

&lt;p&gt;这一部分参考(&lt;a href=&#34;http://www.sohu.com/a/56113983_129720&#34;&gt;http://www.sohu.com/a/56113983_129720&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;聊天机器人的系统框架如下图所示，NLP领域主要以文本输入的聊天机器人为主，因此这里的聊天机器人主要以自然语言理解、对话管理和自然语言生成三个模块为主。&lt;/p&gt;

&lt;p&gt;![聊天机器人的系统框架图](&lt;a href=&#34;https://github.com/jingyihiter/jingyihiter.github.io/blob/master/css/images/the_architecture_of_chatbot.png）&#34;&gt;https://github.com/jingyihiter/jingyihiter.github.io/blob/master/css/images/the_architecture_of_chatbot.png）&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;自然语言理解:5c282e2caebe9b19eac140714253a324&#34;&gt;&lt;strong&gt;自然语言理解&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;自然语言理解的目的是为聊天任务生成一种语义表示形式。通常来说，聊天机器人系统中的自然语言理解功能包括&lt;strong&gt;用户意图识别、用户情感识别、指代消解、省略恢复、回复确认及拒识判断&lt;/strong&gt;等技术&lt;/p&gt;

&lt;p&gt;1）&lt;strong&gt;用户意图识别&lt;/strong&gt;：用户意图又包括显式意图和隐式意图，显示的意图通常对应一个明确的需求，而隐式意图则较难判断，如用户输入“我的手机用了三年了”，有可能想要换一个手机或者显示其手机性能和质量良好。&lt;/p&gt;

&lt;p&gt;2）&lt;strong&gt;用户情感识别&lt;/strong&gt;：用户情感同样也包含显式和隐式两种，如用户输入“我今天非常高兴”，明确表明了喜悦的情感，而“今天考试刚刚及格”，则不太容易判断用户的情感。&lt;/p&gt;

&lt;p&gt;3）&lt;strong&gt;指代消解和省略恢复&lt;/strong&gt;：在对话过程中，由于人们之间具备聊天主题背景一致性的前提，用户通常使用代词来指代上文中的某个实体或事件，或者干脆省略一部分句子成分。但对于聊天机器人系统来说只有明确了代词指代的成分以及句子中省略的成分，才能正确理解用户的输入，给出合乎上下文语义的回复。因此需要进行代词的消解和省略的恢复。&lt;/p&gt;

&lt;p&gt;4）&lt;strong&gt;回复确认&lt;/strong&gt;：用户意图有时会带有一定的模糊性，这时就需要系统具有主动询问的功能，进而对模糊的意图进行确认，即回复确认。&lt;/p&gt;

&lt;p&gt;5）&lt;strong&gt;拒识判断&lt;/strong&gt;：聊天机器人系统应当具备一定的拒识能力，主动拒绝识别超出自身回复范围之外或者涉及敏感话题的用户输入。&lt;/p&gt;

&lt;h2 id=&#34;对话管理:5c282e2caebe9b19eac140714253a324&#34;&gt;&lt;strong&gt;对话管理&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;对话管理功能主要协调聊天机器人的各个部分，并维护对话的结构和状态。对话管理功能中涉及到的关键技术主要有&lt;strong&gt;对话行为识别、对话状态识别、对话策略学习及对话奖励&lt;/strong&gt;等。&lt;/p&gt;

&lt;p&gt;1）&lt;strong&gt;对话行为识别&lt;/strong&gt;：对话行为是指预先定义或者动态生成的对话意图的抽象表示形式。分为封闭式和开放式两种，所谓封闭式对话行为，即将对话意图映射到预先定义好的对话行为类别体系。常见于特定领域或特定任务的对话系统，如票务预订、酒店预订等，例如：“我想预订一个标准间”，这句话被识别为Reservation(Standard_room) 的对话行为。相对的，开放式对话行为则没有预先定义好的对话行为类别体系，对话行为动态生成。常见于开放域对话系统，如聊天机器人。例如：“今天心情真好啊”，这句话的对话行为可以通过隐式的主题、N元组、相似句子簇、连续向量等形式表达。&lt;/p&gt;

&lt;p&gt;2）&lt;strong&gt;对话状态识别&lt;/strong&gt;：对话状态与对话的时序及对话行为相关联，在t时刻的对话行为序列即为t时刻的对话状态。因此，对话状态的转移就由前一时刻的对话状态与当前时刻的对话行为决定。&lt;/p&gt;

&lt;p&gt;3）&lt;strong&gt;对话策略学习&lt;/strong&gt;：通常是通过离线的方式，从人-人对话数据中学习对话的行为、状态、流行度等信息，从而作为指导人-机对话的策略。这里流行度通常是指特定模式在语料库中的频度。&lt;/p&gt;

&lt;p&gt;4）&lt;strong&gt;对话奖励&lt;/strong&gt;：对话奖励是对话系统的中间级评价机制，但会影响对话系统的整体评价。常见的对话奖励有槽填充效率和回复流行度等。&lt;/p&gt;

&lt;h2 id=&#34;自然语言生成:5c282e2caebe9b19eac140714253a324&#34;&gt;自然语言生成&lt;/h2&gt;

&lt;p&gt;自然语言生成通常根据对话管理部分产生的非语言信息，自动生成面向用户的自然语言反馈。近年来，在聊天机器人系统上的对话生成主要涉及&lt;strong&gt;检索式和生成式&lt;/strong&gt;两类技术。&lt;/p&gt;

&lt;p&gt;1）&lt;strong&gt;检索式对话生成技术&lt;/strong&gt;：检索式的代表性技术是在已有的人人对话语料库中通过排序学习技术和深度匹配技术找到适合当前输入的最佳回复。这种方法的局限是仅能以固定的语言模式进行回复，无法实现词语的多样性组合。&lt;/p&gt;

&lt;p&gt;2）&lt;strong&gt;生成式对话生成技术&lt;/strong&gt;：生成式的代表性技术则是从已有的人人对话中学习语言的组合模式，是通过一种类似机器翻译中常用的“编码-解码”的过程去逐字或逐词地生成一个回复，这种回复有可能是从未在语料库中出现的、由聊天机器人自己“创造”出来的句子。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;聊天机器人研究存在的挑战&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;聊天机器人的研究存在的挑战包括：对话上下文建模、对话过程中的知识表示、对话策略学习、聊天机器人智能程度的评价等。&lt;/p&gt;

&lt;p&gt;1）&lt;strong&gt;对话上下文建模&lt;/strong&gt;：聊天是一个有特定背景的连续交互过程，在这一过程中经常出现上下文省略和指代的情况。一句话的意义有时要结合对话上下文或者相关的背景才能确定，而现有的自然语言理解主要基于上下文无关假设，因此对话上下文的建模成为聊天机器人系统的主要挑战之一。&lt;/p&gt;

&lt;p&gt;2）&lt;strong&gt;对话过程中的知识表示&lt;/strong&gt;：知识表示一直就是人工智能领域的重要课题，也是聊天机器人提供信息服务的基础。聊天机器人相关的领域任务可能有复杂的组成，牵涉很多的因素，只有了解这些因素的关系和相关的含义，才能与用户做到真正意义上的交流。&lt;/p&gt;

&lt;p&gt;3）&lt;strong&gt;对话策略学习&lt;/strong&gt;：对话策略涉及很多方面，其中最主要的是对话的主导方式。对话主导方式可以分为用户主导、系统主导和混合主导三种方式。在当前的对话管理研究中，系统应答的目标是自然、友好、积极，在不会发生问题的情况下，让用户尽可能自主，实现对话的混合主导。&lt;/p&gt;

&lt;p&gt;4）&lt;strong&gt;聊天机器人智能程度的评价&lt;/strong&gt;：目前聊天机器人智能程度的评价也是一项挑战。虽然可以采用一些通用的客观评价标准，如回答正确率、任务完成率、对话回合数、对话时间、系统平均响应时间、错误信息率等，对聊天机器人进行评价，评价的基本单元是单轮对话。但是，由于人机对话过程是一个连续的过程，而对不同聊天机器人系统的连续对话的评价仅能保证首句输入的一致性，当对话展开后，不同系统的回复不尽相同，因此不能简单地将连续对话切分成单轮对话去评价，于是设计合理的人工主观评价也许能够成为客观评价标准之外，对聊天机器人系统智能程度评价的重要指标。&lt;/p&gt;

&lt;h1 id=&#34;2-聊天机器人的现有解决方案:5c282e2caebe9b19eac140714253a324&#34;&gt;2、聊天机器人的现有解决方案&lt;/h1&gt;

&lt;p&gt;闲聊机器人问题的组成：&lt;/p&gt;

&lt;p&gt;2.1、答案生成（选择）&lt;/p&gt;

&lt;p&gt;Solution1: 基于规则的聊天机器人：&lt;/p&gt;

&lt;p&gt;通过人工设定对话场景，并对每个场景写一些针对性的对话模板或规则库，所有问题的答案均是根据已建立的规则库进行规则匹配和推理得到,具有准确性高、知识获取便捷的特点。&lt;/p&gt;

&lt;p&gt;优点：精准性高&lt;/p&gt;

&lt;p&gt;缺点：需要大量人工工作，而且可扩展性差；&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/jingyihiter/jingyihiter.github.io/blob/master/css/images/Architecture_of_chatbot_based_on_rule.png&#34; alt=&#34;一个基于规则的聊天机器人的系统结构图&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Solution2: 基于检索的聊天机器人：&lt;/p&gt;

&lt;p&gt;1、预先存储好对话库并建立索引&lt;/p&gt;

&lt;p&gt;2、根据用户问句，在对话库中进行模糊匹配找到最合适的应答内容&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/jingyihiter/jingyihiter.github.io/blob/master/css/images/wechat_robot_based_on_IR.png&#34; alt=&#34;基于检索的微信聊天机器人&#34; /&gt;
Solution3: 基于深度学习的聊天机器人&lt;/p&gt;

&lt;p&gt;根据context来生成对话，如seq2seq+attention框架&lt;/p&gt;

&lt;p&gt;1、Encoder：压缩表示当前用户问题与上下文信息
 2、Decoder：解码出答案
&lt;img src=&#34;https://github.com/jingyihiter/jingyihiter.github.io/blob/master/css/images/Architercture_of_chatbot_based_on_Deep_Learning.png&#34; alt=&#34;一个基于深度学习的聊天机器人的系统&#34; /&gt;
3、面临的问题：&lt;/p&gt;

&lt;p&gt;聊天机器人的评价标准&lt;/p&gt;

&lt;p&gt;缺乏标准化的大规模训练数据&lt;/p&gt;

&lt;p&gt;“安全回答”（Safe Response）问题：聊天机器人都用少数非常常见的句子进行应答&lt;/p&gt;

&lt;p&gt;个性信息一致性问题&lt;/p&gt;

&lt;p&gt;2.2、对话状态跟踪&lt;/p&gt;

&lt;p&gt;理解或者捕捉user intention或者goal&lt;/p&gt;

&lt;p&gt;2.3、用户建模&lt;/p&gt;

&lt;p&gt;3.1对于复杂、细致的业务，需要对用户建模，相同的问题，bot给每个人的response是不同的。&lt;/p&gt;

&lt;p&gt;3.2用户建模需要涉及的不仅仅是简单的用户基本信息和用户的一些显式反馈信息，而更重要的是用户的history conversations，这些隐式的反馈信息。&lt;/p&gt;

&lt;p&gt;3.3 对user进行建模，就是做一个个性化的bot，生成的每一个response都有这个user鲜明的特点&lt;/p&gt;

&lt;p&gt;2.4 闲聊机器人的性能评价&lt;/p&gt;

&lt;p&gt;采用机器翻译中的bleu值，  对话的平均轮数，  人工进行评价。其中设计评价机制评分，进行人工评价更有说服力。&lt;/p&gt;

&lt;p&gt;Reference:&lt;/p&gt;

&lt;p&gt;[1] &lt;a href=&#34;http://www.sohu.com/a/110529212_119709&#34;&gt;http://www.sohu.com/a/110529212_119709&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[2] &lt;a href=&#34;http://blog.csdn.net/malefactor/article/details/51901115&#34;&gt;http://blog.csdn.net/malefactor/article/details/51901115&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[3] 王磊,魏勇,邸建勋,杨小琳. 本体聊天机器人的设计与应用[J]. 自动化与信息工程,2016,37(04):13-18&lt;/p&gt;

&lt;h1 id=&#34;3-微软小冰的例子:5c282e2caebe9b19eac140714253a324&#34;&gt;3、微软小冰的例子&lt;/h1&gt;

&lt;p&gt;参考（&lt;a href=&#34;http://www.ccf.org.cn/sites/weixin/chatbot.pdf&#34;&gt;http://www.ccf.org.cn/sites/weixin/chatbot.pdf&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;小冰作为闲聊机器人，它的聊天引擎主要有：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;底层&lt;/strong&gt;：数据层，包含普通数据，抽取的聊天知识&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;中间层&lt;/strong&gt;：引擎与技术，比如闲聊引擎，问答引擎，Task-completion引擎，基于搜索和基于生成的技术。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;上层&lt;/strong&gt;：用户画像、上下文场景，通过聊天建立用户画像和上下文场景。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;闲聊引擎&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;1）个性化聊天：根据用户不同作不同倾向性的回复，根据用户画像选最优的回复&lt;/p&gt;

&lt;p&gt;2）深度聊天：即针对某些重点话题整理聊天知识，使得聊天内容更加深入和丰富&lt;/p&gt;

&lt;p&gt;3）基于图片的聊天：根据对图片的识别和理解，形成聊天&lt;/p&gt;

&lt;p&gt;4）基于图片标题的聊天：根据图片的内容和对图片标题的描述，生成评论性的聊天&lt;/p&gt;

&lt;h1 id=&#34;4-实现聊天机器人的技术:5c282e2caebe9b19eac140714253a324&#34;&gt;4、实现聊天机器人的技术&lt;/h1&gt;

&lt;p&gt;搭建一个简单的聊天机器人demo需要的技术&lt;/p&gt;

&lt;h2 id=&#34;4-1-数据集:5c282e2caebe9b19eac140714253a324&#34;&gt;4.1 数据集&lt;/h2&gt;

&lt;p&gt;对话系统的数据集(参考：&lt;a href=&#34;https://github.com/candlewill/Dialog_Corpus&#34;&gt;https://github.com/candlewill/Dialog_Corpus&lt;/a&gt;)：&lt;/p&gt;

&lt;p&gt;1) &lt;a href=&#34;https://github.com/rustch3n/dgk_lost_conv&#34;&gt;dgk_shooter_min.conv.zip&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;中文电影对白语料，噪音比较大，许多对白问答关系没有对应好&lt;/p&gt;

&lt;p&gt;2) &lt;a href=&#34;https://github.com/kite1988/nus-sms-corpus&#34;&gt;The NUS SMS Corpus&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;包含中文和英文短信息语料，据说是世界最大公开的短消息语料&lt;/p&gt;

&lt;p&gt;3) &lt;a href=&#34;https://github.com/gunthercox/chatterbot-corpus/tree/master/chatterbot_corpus/data&#34;&gt;ChatterBot中文基本聊天语料&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ChatterBot聊天引擎提供的一点基本中文聊天语料，量很少，但质量比较高&lt;/p&gt;

&lt;p&gt;4) &lt;a href=&#34;https://github.com/karthikncode/nlp-datasets&#34;&gt;Datasets for Natural Language Processing&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这是他人收集的自然语言处理相关数据集，主要包含Question Answering，Dialogue Systems， Goal-Oriented Dialogue Systems三部分，都是英文文本。可以使用机器翻译为中文，供中文对话使用&lt;/p&gt;

&lt;p&gt;5) &lt;a href=&#34;https://github.com/rustch3n/dgk_lost_conv/tree/master/results&#34;&gt;小黄鸡&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;据传这就是小黄鸡的语料：xiaohuangji50w_fenciA.conv.zip （已分词） 和 xiaohuangji50w_nofenci.conv.zip （未分词）&lt;/p&gt;

&lt;p&gt;6) &lt;a href=&#34;https://github.com/Samurais/egret-wenda-corpus&#34;&gt;白鹭时代中文问答语料&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;由白鹭时代官方论坛问答板块10,000+ 问题中，选择被标注了“最佳答案”的纪录汇总而成。人工review raw data，给每一个问题，一个可以接受的答案。目前，语料库只包含2907个问答。(备份)&lt;/p&gt;

&lt;p&gt;7) &lt;a href=&#34;https://github.com/Marsan-Ma/chat_corpus&#34;&gt;Chat corpus repository&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;chat corpus collection from various open sources&lt;/p&gt;

&lt;p&gt;包括：开放字幕、英文电影字幕、中文歌词、英文推文&lt;/p&gt;

&lt;p&gt;8) &lt;a href=&#34;https://github.com/Samurais/insuranceqa-corpus-zh&#34;&gt;保险行业QA语料库&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;通过翻译 insuranceQA产生的数据集。train_data含有问题12,889条，数据 141779条，正例：负例 = 1:10； test_data含有问题2,000条，数据 22000条，正例：负例 = 1:10；valid_data含有问题2,000条，数据 22000条，正例：负例 = 1:10&lt;/p&gt;

&lt;h2 id=&#34;4-2-基于规则与检索的聊天机器人:5c282e2caebe9b19eac140714253a324&#34;&gt;4.2 基于规则与检索的聊天机器人&lt;/h2&gt;

&lt;p&gt;利用开源的搜索引擎做检索(参考：&lt;a href=&#34;https://www.zhihu.com/question/19583321&#34;&gt;https://www.zhihu.com/question/19583321&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;Lucene及其变种&lt;/p&gt;

&lt;p&gt;· Lucene &lt;a href=&#34;https://link.zhihu.com/?target=http%3A//lucene.apache.org/&#34;&gt;http://lucene.apache.org/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;· Solr   &lt;a href=&#34;http://lucene.apache.org/solr/&#34;&gt;http://lucene.apache.org/solr/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;· Elasticsearch &lt;a href=&#34;https://link.zhihu.com/?target=http%3A//www.elasticsearch.org/&#34;&gt;http://www.elasticsearch.org/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Zettair &lt;a href=&#34;https://link.zhihu.com/?target=http%3A//www.seg.rmit.edu.au/zettair/&#34;&gt;http://www.seg.rmit.edu.au/zettair/&lt;/a&gt; Indri &lt;a href=&#34;https://link.zhihu.com/?target=http%3A//www.lemurproject.org/indri/&#34;&gt;http://www.lemurproject.org/indri/&lt;/a&gt; Terrier &lt;a href=&#34;https://link.zhihu.com/?target=http%3A//terrier.org/&#34;&gt;http://terrier.org/&lt;/a&gt; Galago &lt;a href=&#34;https://link.zhihu.com/?target=http%3A//www.galagosearch.org/&#34;&gt;http://www.galagosearch.org/&lt;/a&gt; Zebra &lt;a href=&#34;https://link.zhihu.com/?target=https%3A//www.indexdata.com/zebra&#34;&gt;https://www.indexdata.com/zebra&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Sphinx &lt;a href=&#34;http://sphinxsearch.com/&#34;&gt;http://sphinxsearch.com/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;4-3-基于生成式的聊天机器人:5c282e2caebe9b19eac140714253a324&#34;&gt;4.3 基于生成式的聊天机器人&lt;/h2&gt;

&lt;p&gt;基于Seq2Seq模型的回复生成：&lt;/p&gt;

&lt;p&gt;传统的seq2seq模型以及针对聊天机器人的各种变种模型&lt;/p&gt;

&lt;p&gt;(深度学习框架Theano,Tensorflow,Torch等)&lt;/p&gt;

&lt;p&gt;(致谢：感谢Huanqin Wu的参与)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>小影机器人使用说明</title>
      <link>https://jingyihiter.github.io/2017/05/01/%E5%B0%8F%E5%BD%B1%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E</link>
      <pubDate>Mon, 01 May 2017 10:59:46 +0800</pubDate>
      
      <guid>https://jingyihiter.github.io/2017/05/01/%E5%B0%8F%E5%BD%B1%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E</guid>
      <description>

&lt;h1 id=&#34;小影机器人使用说明:8d2445c903175ede941abe826bf4b8f5&#34;&gt;小影机器人使用说明&lt;/h1&gt;

&lt;p&gt;一、群聊中通过@小影进行提问，小影会@用户进行回答。如图
    &lt;img src=&#34;https://github.com/jingyihiter/jingyihiter.github.io/raw/master/css/images/wcbot.png&#34; alt=&#34;&#34; /&gt;
二、对于小影无法回答的问题，会在在其他群里进行转发问题，搜集到答案再返回给用户&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;回答问题的格式： 回答id:* xxxx 其中*代表问题的编号，在转发问题时会有问题的编号&lt;br&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/jingyihiter/jingyihiter.github.io/raw/master/css/images/wcbot_ask.png&#34; alt=&#34;&#34; /&gt;
 &lt;img src=&#34;https://github.com/jingyihiter/jingyihiter.github.io/raw/master/css/images/wcbot_give_answer.png&#34; alt=&#34;&#34; /&gt;
 &lt;img src=&#34;https://github.com/jingyihiter/jingyihiter.github.io/raw/master/css/images/wcbot_answers.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;三、对于发广告的用户，请发消息举报：举报@xx 如图
    &lt;img src=&#34;https://github.com/jingyihiter/jingyihiter.github.io/raw/master/css/images/wcbot_jubao.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>双系统直接进入grub不能进入ubantu解决方案</title>
      <link>https://jingyihiter.github.io/2017/04/11/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E7%9B%B4%E6%8E%A5%E8%BF%9B%E5%85%A5grub%E4%B8%8D%E8%83%BD%E8%BF%9B%E5%85%A5ubantu%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88</link>
      <pubDate>Tue, 11 Apr 2017 03:15:08 +0800</pubDate>
      
      <guid>https://jingyihiter.github.io/2017/04/11/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E7%9B%B4%E6%8E%A5%E8%BF%9B%E5%85%A5grub%E4%B8%8D%E8%83%BD%E8%BF%9B%E5%85%A5ubantu%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88</guid>
      <description>

&lt;h2 id=&#34;双系统直接进入grub不能进入ubantu解决方案:f739cf6a6d84c35d7b574e0cf845e77d&#34;&gt;双系统直接进入grub不能进入ubantu解决方案&lt;/h2&gt;

&lt;p&gt;背景：安装window10和ubantu的双系统&lt;/p&gt;

&lt;p&gt;问题：
&amp;gt;1、在ubantu安装之后不能进入系统，反而直接进入grub命令。&lt;br&gt;
 2、在windows系统，使用easybcd无法给linux添加启动项。Linux的那部分是灰色的&lt;/p&gt;

&lt;p&gt;暂时进入ubantu的方法：&lt;br&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grub&amp;gt;set root=(hd0,5)
grub&amp;gt;set prefix=(hd0,5)/grub
grub&amp;gt;insmod /grub/normal.mod
grub&amp;gt;normal 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://zhidao.baidu.com/question/368384875696974604.html&#34;&gt;方法来源-百度知道&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;按照上述方法进入之后，选择更新grub，以及安装grub。但是会出现以下错误。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grub-install:warning :无法嵌入。在此次安装中GRUB只能通过使用块列表安装。但是块列表是不可信赖的，不推荐使用。
grub-install:错误：will not proceed with blocklists
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;发现一个&lt;strong&gt;BOOT-REPAIR&lt;/strong&gt;的工具，抱着试试的态度安装了。&lt;br&gt;
&lt;a href=&#34;http://jingyan.baidu.com/article/5553fa82cd48a765a23934ae.html&#34;&gt;安装-百度经验&lt;/a&gt;&lt;br&gt;
按照步骤安装试试。如果中间出现问题，重启电脑再进入ubantu，再试一遍。我是第二次才可以的.
在扫描修复过程中，会给出对应命令进行对grub2卸载重装，按照命令进行操作，最终修复成功。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>爬虫模拟登录豆瓣</title>
      <link>https://jingyihiter.github.io/2017/04/09/%E7%88%AC%E8%99%AB%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95%E8%B1%86%E7%93%A3</link>
      <pubDate>Sun, 09 Apr 2017 11:45:08 +0800</pubDate>
      
      <guid>https://jingyihiter.github.io/2017/04/09/%E7%88%AC%E8%99%AB%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95%E8%B1%86%E7%93%A3</guid>
      <description>

&lt;h2 id=&#34;网络爬虫-模拟登录豆瓣:9e0f1c7021fb77d2438aa4a26d495c1d&#34;&gt;网络爬虫——模拟登录豆瓣&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;# -*- coding: utf-8 -*-
&amp;quot;&amp;quot;&amp;quot;
Created on Sat Apr 01 13:44:51 2017

@author: 马晶义
&amp;quot;&amp;quot;&amp;quot;

import requests
import re
headers = {
    &amp;quot;Host&amp;quot;:&amp;quot;www.douban.com&amp;quot;,
    &amp;quot;User-Agent&amp;quot;:&amp;quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36&amp;quot;,
    &amp;quot;Accept-Language&amp;quot;:&amp;quot;zh-CN,zh;q=0.8,zh-TW;q=0.6&amp;quot;,
    &amp;quot;Accept-Encoding&amp;quot;:&amp;quot;gzip, deflate, sdch, br&amp;quot;,
    &amp;quot;Connection&amp;quot;:&amp;quot;keep-alive&amp;quot;
    }

def login():
    login_str = u&#39;登录&#39;
    data = {
    #&#39;ck&#39;:&#39;GiW5&#39;,
    &#39;source&#39;:&#39;None&#39;,
    #&#39;redir&#39;:&#39;https://movie.douban.com/&#39;,
    &#39;form_email&#39;:&#39;xxxxxx&#39;,
    &#39;form_password&#39;:&#39;xxxxx&#39;,
    #&#39;captcha_solution&#39;:captcha_solution,
    #&#39;captcha_id&#39;:captcha_id,
    &#39;login&#39;:login_str
    }
    login_url = &#39;https://www.douban.com/accounts/login&#39;
    session = requests.session()
    html = session.get(login_url,headers=headers).text
    captcha_img_pattern = r&#39;(?&amp;lt;=&amp;lt;img id=&amp;quot;captcha_image&amp;quot; src=\&amp;quot;).*?(?=\&amp;quot;)&#39;
    captcha_image_url = re.search(captcha_img_pattern,html,re.S|re.M|re.I)
    if captcha_image_url is not None:
        captcha_image_url = captcha_image_url.group()
        print captcha_image_url
        #captcha_image = session.get(captcha_image_url).text
        captcha_image = requests.get(captcha_image_url,headers=headers).content
        document =&#39;login_captcha_douban.jpg&#39; 
        file_ = open(document,&#39;wb&#39;)
        file_.write(captcha_image)
        file_.close()
        captcha_solution = raw_input(&#39;captcha_solution:&#39;)
        data[&#39;captcha-solution&#39;] = captcha_solution
        #获取captcha_id
        captcha_id_pattern = r&#39;(?&amp;lt;=&amp;lt;input type=&amp;quot;hidden&amp;quot; name=&amp;quot;captcha-id&amp;quot; value=\&amp;quot;).*?(?=\&amp;quot;/&amp;gt;)&#39;
        captcha_id = re.search(captcha_id_pattern,html,re.S|re.M|re.I)
        if captcha_id is None:
            print &#39;captcha_id error&#39;
        else:
            captcha_id = captcha_id.group()
            data[&#39;captcha-id&#39;] = captcha_id
    session.post(login_url,headers=headers,data=data)
    print data
    print session.cookies.items()
    return session


def main():
    session = login()
    usinfo = session.get(&#39;https://www.douban.com/people/146365045/&#39;,headers=headers).text
    #输出你的用户名
    print (re.search(r&#39;(?&amp;lt;=&amp;lt;title&amp;gt;).*?(?=&amp;lt;/title&amp;gt;)&#39;,usinfo,re.M|re.I|re.S)).group()
    usinfo = usinfo.encode(&#39;utf-8&#39;)  #保存你个人信息页面
    file_=open(&#39;use.html&#39;,&#39;wb&#39;)
    file_.write(usinfo)
    file_.close()

main()
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>KB-QA系统paper推荐</title>
      <link>https://jingyihiter.github.io/2017/03/29/kb-qa%E7%B3%BB%E7%BB%9Fpaper%E6%8E%A8%E8%8D%90</link>
      <pubDate>Wed, 29 Mar 2017 20:43:29 +0800</pubDate>
      
      <guid>https://jingyihiter.github.io/2017/03/29/kb-qa%E7%B3%BB%E7%BB%9Fpaper%E6%8E%A8%E8%8D%90</guid>
      <description>

&lt;h1 id=&#34;基于知识库的问答系统-kb-qa-paper推荐:d582df2b1cf9bb3616ee259c8891eb63&#34;&gt;基于知识库的问答系统 KB-QA paper推荐&lt;/h1&gt;

&lt;h2 id=&#34;注-文章推荐来自于知乎专栏-刘大一恒-作者:d582df2b1cf9bb3616ee259c8891eb63&#34;&gt;注：文章推荐来自于知乎专栏&amp;ndash;刘大一恒（作者）&lt;/h2&gt;

&lt;p&gt;由于毕设是问答系统，因此需要读相关的文献，刘博士这里推荐的都很不错。专门都下载下来，留下来自己研读，当然也推荐给大家。&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://pan.baidu.com/s/1hr4Q2LQ&#34;&gt;paper下载地址&lt;/a&gt; 密码：j6xp &lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;语义解析部分paper-br:d582df2b1cf9bb3616ee259c8891eb63&#34;&gt;语义解析部分paper&lt;br&gt;&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Berant J, Chou A, Frostig R, et al. Semantic Parsing on Freebase from Question-Answer Pairs[C]//EMNLP. 2013, 2(5): 6.&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Cai Q, Yates A. Large-scale Semantic Parsing via Schema Matching and Lexicon Extension[C]//ACL (1). 2013: 423-433.&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Kwiatkowski T, Choi E, Artzi Y, et al. Scaling semantic parsers with on-the-fly ontology matching[C]//In Proceedings of EMNLP. Percy. 2013.&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Fader A, Zettlemoyer L, Etzioni O. Open question answering over curated and extracted knowledge bases[C]//Proceedings of the 20th ACM SIGKDD international conference on Knowledge discovery and data mining. ACM, 2014: 1156-1165.&lt;br&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;信息抽取-br:d582df2b1cf9bb3616ee259c8891eb63&#34;&gt;信息抽取&lt;br&gt;&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Yao X, Van Durme B. Information Extraction over Structured Data: Question Answering with Freebase[C]//ACL (1). 2014: 956-966.&lt;br&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;向量建模方法-br:d582df2b1cf9bb3616ee259c8891eb63&#34;&gt;向量建模方法&lt;br&gt;&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Bordes A, Chopra S, Weston J. Question answering with subgraph embeddings[J]. arXiv preprint arXiv:1406.3676, 2014.&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Yang M C, Duan N, Zhou M, et al. Joint Relational Embeddings for Knowledge-based Question Answering[C]//EMNLP. 2014, 14: 645-650.&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Bordes A, Weston J, Usunier N. Open question answering with weakly supervised embedding models[C]//Joint European Conference on Machine Learning and Knowledge Discovery in Databases. Springer Berlin Heidelberg, 2014: 165-180.&lt;br&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;卷积神经网络对向量建模-br:d582df2b1cf9bb3616ee259c8891eb63&#34;&gt;卷积神经网络对向量建模&lt;br&gt;&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Dong L, Wei F, Zhou M, et al. Question Answering over Freebase with Multi-Column Convolutional Neural Networks[C]//ACL (1). 2015: 260-269.&lt;br&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;卷积神经网络对语义解析-br:d582df2b1cf9bb3616ee259c8891eb63&#34;&gt;卷积神经网络对语义解析&lt;br&gt;&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Yih S W, Chang M W, He X, et al. Semantic parsing via staged query graph generation: Question answering with knowledge base[J]. 2015. &lt;br&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;lstm-cnn实体分类-br:d582df2b1cf9bb3616ee259c8891eb63&#34;&gt;LSTM CNN实体分类&lt;br&gt;&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Xu Y, Mou L, Li G, et al. Classifying Relations via Long Short Term Memory Networks along Shortest Dependency Paths[C]//EMNLP. 2015: 1785-1794.&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Zeng D, Liu K, Lai S, et al. Relation Classification via Convolutional Deep Neural Network[C]//COLING. 2014: 2335-2344.（Best paper）&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Zeng D, Liu K, Chen Y, et al. Distant Supervision for Relation Extraction via Piecewise Convolutional Neural Networks[C]//EMNLP. 2015: 1753-1762.&lt;br&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;记忆网络-注意力机制-br:d582df2b1cf9bb3616ee259c8891eb63&#34;&gt;记忆网络，注意力机制&lt;br&gt;&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Bordes A, Usunier N, Chopra S, et al. Large-scale simple question answering with memory networks[J]. arXiv preprint arXiv:1506.02075, 2015.&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Zhang Y, Liu K, He S, et al. Question Answering over Knowledge Base with Neural Attention Combining Global Knowledge Information[J]. arXiv preprint arXiv:1606.00979, 2016.&lt;br&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>IOError: No wkhtmltopdf executable found</title>
      <link>https://jingyihiter.github.io/2016/07/04/ioerror-no-wkhtmltopdf-executable-found</link>
      <pubDate>Mon, 04 Jul 2016 01:04:16 +0800</pubDate>
      
      <guid>https://jingyihiter.github.io/2016/07/04/ioerror-no-wkhtmltopdf-executable-found</guid>
      <description>&lt;p&gt;#IOError: No wkhtmltopdf executable found: &amp;ldquo;&amp;rdquo;&lt;/p&gt;

&lt;p&gt;python使用pdfkit中，如果使用pdfkit.from_url 或者pdfkit.from_string等，就会出现上述错误。而且如果你使用pip安装了 &lt;strong&gt;&lt;em&gt;wkhtmltopdf&lt;/em&gt;&lt;/strong&gt;，还是会出现这个问题：&lt;br&gt;
If this file exists please check that this process can read it. Otherwise please install wkhtmltopdf - &lt;a href=&#34;https://github.com/JazzCore/python-pdfkit/wiki/Installing-wkhtmltopdf&#34;&gt;https://github.com/JazzCore/python-pdfkit/wiki/Installing-wkhtmltopdf&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;因此需要去安装windows版本的&lt;strong&gt;&lt;em&gt;wkhtmltopdf&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;
&lt;a href=&#34;http://wkhtmltopdf.org/downloads.html&#34;&gt;此处进入下载网址&lt;/a&gt;&lt;br&gt;
安装完成之后需要在代码中添加以下内容：&lt;br&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;path_wk = r&#39;C:\Python27\wkhtmltopdf\bin\wkhtmltopdf.exe&#39; #安装位置
config = pdfkit.configuration(wkhtmltopdf = path_wk)
pdfkit.from_url(url, r&#39;D:\are you coding\pdf\taobao.pdf&#39;, configuration=config)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如此即可实现了&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>python学习——保存网页到本地 html及pdf</title>
      <link>https://jingyihiter.github.io/2016/07/04/python%E5%AD%A6%E4%B9%A0%E4%BF%9D%E5%AD%98%E7%BD%91%E9%A1%B5%E5%88%B0%E6%9C%AC%E5%9C%B0-html%E5%8F%8Apdf</link>
      <pubDate>Mon, 04 Jul 2016 01:04:01 +0800</pubDate>
      
      <guid>https://jingyihiter.github.io/2016/07/04/python%E5%AD%A6%E4%B9%A0%E4%BF%9D%E5%AD%98%E7%BD%91%E9%A1%B5%E5%88%B0%E6%9C%AC%E5%9C%B0-html%E5%8F%8Apdf</guid>
      <description>&lt;p&gt;#python学习——保存网页到本地 html及pdf&lt;/p&gt;

&lt;p&gt;直接上代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# -*- coding: utf-8 -*-
&amp;quot;&amp;quot;&amp;quot;
Created on Tue Jun 14 13:01:58 2016

@author: 
&amp;quot;&amp;quot;&amp;quot;

import urllib2
import cookielib
import pdfkit

cj = cookielib.LWPCookieJar()
opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cj))
urllib2.install_opener(opener)
url = &amp;quot;https://www.taobao.com/&amp;quot;
req = urllib2.Request(url)
&#39;&#39;&#39; 保存html到本地&#39;&#39;&#39;
operate = opener.open(req)
msg = operate.read()
document = &#39;D://1.html&#39;  
file_ = open(document,&#39;w&#39;)   
file_.write(msg)
file_.close()

path_wk = r&#39;C:\Python27\wkhtmltopdf\bin\wkhtmltopdf.exe&#39;
config = pdfkit.configuration(wkhtmltopdf = path_wk)

&#39;&#39;&#39;保存pdf到本地&#39;&#39;&#39;
pdfkit.from_url(url, r&#39;D:\are you coding\pdf\taobao.pdf&#39;, configuration=config)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>GBN协议的实现</title>
      <link>https://jingyihiter.github.io/2016/07/01/gbn%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AE%9E%E7%8E%B0</link>
      <pubDate>Fri, 01 Jul 2016 00:30:47 +0800</pubDate>
      
      <guid>https://jingyihiter.github.io/2016/07/01/gbn%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AE%9E%E7%8E%B0</guid>
      <description>

&lt;h1 id=&#34;二-计算机网络之gbn协议的实现:a6ef90ec143a8509356ee3058751c59e&#34;&gt;二、计算机网络之GBN协议的实现&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/jingyihiter/GBN.git&#34;&gt;源码下载&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;实验内容-br:a6ef90ec143a8509356ee3058751c59e&#34;&gt;&lt;strong&gt;实验内容：&lt;/strong&gt;&lt;br&gt;&lt;/h2&gt;

&lt;p&gt;1) 基于UDP设计一个简单的GBN协议， 实现单向可靠数据传输 （服务器到客户的数据传输） 。&lt;br&gt;
2) 模拟引入数据包的丢失，验证所设计协议的有效性。&lt;br&gt;
3) 改进所设计的 GBN 协议，支持双向数据传输； （选作内容，加分项目，可以当堂完成或课下完成）&lt;br&gt;
4）将所设计的 GBN 协议改进为 SR 协议。 （选作内容，加分项目,可以当堂完成或课下完成）&lt;br&gt;
&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;实验原理及参考-br:a6ef90ec143a8509356ee3058751c59e&#34;&gt;实验原理及参考：&lt;br&gt;&lt;/h2&gt;

&lt;p&gt;实验原理图&lt;br&gt;
&lt;img src=&#34;https://github.com/jingyihiter/jingyihiter.github.io/raw/master/css/images/GBN.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;作为只实现单向数据传输的 GBN 协议，实质上就是实现为一个 C/S应用。&lt;br&gt;
服务器端：使用 UDP 协议传输数据（比如传输一个文件） ，等待客户端的请求，接收并处理来自客户端的消息（如数据传输请求） ，当客户端开始请求数据时进入“伪连接”状态（并不是真正的连接，只是一种类似连接的数据发送的状态） ，将数据打包成数据报发送，然后等待客户端的 ACK 信息，同时启动计时器。当收到ACK 时，窗口滑动，正常发送下一个数据报，计时器重新计时；若在计时器超时前没有收到 ACK，则全部重传窗口内的所以已发送的数据报。&lt;br&gt;
&lt;br&gt;
客户端：使用 UDP 协议向服务器端请求数据，接收服务器端发送的数据报并返回确认信息 ACK （注意 GBN 为累积确认， 即若 ACK=1 和 3，表示数据帧 2 已经正确接收） ，必须能够模拟 ACK 丢失直至服务器端超时重传的情况。&lt;br&gt;
&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;服务器端设计参考:a6ef90ec143a8509356ee3058751c59e&#34;&gt;服务器端设计参考&lt;/h2&gt;

&lt;p&gt;1）命令解析&lt;br&gt;
为了测试客户端与服务器端的通信交互，方便操作，设置了此过程。&lt;br&gt;
首先，服务器接收客户端发来的请求数据，&lt;br&gt;
“-time”表示客户端请求获取当前时间，服务器回复当前时间；&lt;br&gt;
“-quit”表示客户端退出，服务器回复“Good bye!”；&lt;br&gt;
“-testgbn”表示客户端请求开始测试 GBN 协议，服务器开始进入GBN 传输状态；其他数据，则服务器直接回复原数据。&lt;br&gt;&lt;br&gt;
2）数据传输数据帧格式定义&lt;br&gt;
在以太网中，数据帧的 MTU 为 1500 字节，所以 UDP 数据报的数据部分应小于 1472 字节（除去 IP 头部 20 字节与 UDP 头的 8 字节） ，为此，定义 UDP 数据报的数据部分格式为：&lt;br&gt;
&lt;img src=&#34;https://github.com/jingyihiter/jingyihiter.github.io/raw/master/css/images/seq.png&#34; alt=&#34;&#34; /&gt;
Seq 为 1 个字节，取值为 0~255， （故序列号最多为 256 个） ；Data≤1024 个字节，为传输的数据；
最后一个字节放入 EOF0，表示结尾&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;客户端设计参考:a6ef90ec143a8509356ee3058751c59e&#34;&gt;客户端设计参考&lt;/h2&gt;

&lt;p&gt;1) ACK 数据帧定义&lt;br&gt;
由于是从服务器端到客户端的单向数据传输， 因此 ACK 数据帧不包含任何数据，只需要将 ACK 发送给服务器端即可。&lt;br&gt;
&lt;img src=&#34;https://github.com/jingyihiter/jingyihiter.github.io/raw/master/css/images/ack.png&#34; alt=&#34;&#34; /&gt;
ACK 字段为一个字节，表示序列号数值；末尾放入 0，表示数据结束。&lt;br&gt;
2）命令设置&lt;br&gt;
客户端的命令和服务器端的解析命令向对应，获取当前用户输入并发送给服务器并等待服务器返回数据，如输入“-time”得到服务器的当前时间。&lt;br&gt;
此处重点介绍“-testgbn [X] [Y]”命令，[X],[Y]均为[0,1]的小数，其中：&lt;br&gt;
[X]表示客户端的丢包率，模拟网络中报文丢失；&lt;br&gt;
[Y]表示客户端的 ACK 的丢失率。 （使用随机函数完成） 。&lt;br&gt;
如果用户不输入，则默认丢失率均为 0.2&lt;br&gt;&lt;/p&gt;

&lt;p&gt;注：参考哈工大计算机网络指导书&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Http代理服务器</title>
      <link>https://jingyihiter.github.io/2016/07/01/http%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8</link>
      <pubDate>Fri, 01 Jul 2016 00:24:46 +0800</pubDate>
      
      <guid>https://jingyihiter.github.io/2016/07/01/http%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8</guid>
      <description>

&lt;h1 id=&#34;一-计算机网络之http代理服务器:7e45868971a7bcd8ef176d27cff9b534&#34;&gt;一、计算机网络之HTTP代理服务器&lt;/h1&gt;

&lt;p&gt;注：参考哈工大计算机网络指导书&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/jingyihiter/http_proxy&#34;&gt;源码下载地址&lt;/a&gt;&lt;br&gt;
&lt;br&gt;
实验的内容：&lt;br&gt;
1.实现基本的HTTP代理服务器,可以在指定端口接收客户端http的请求并且根据其中个URL地址访问该地址所指向的HTTP服务器，接收服务器的响应报文，并将响应报文转发给对应的客户进行浏览。&lt;br&gt;
2.设计并实现一个支持cache功能的HTTP代理服务器，要求能缓存原服务器响应的对象，并能够通过修改请求报文（添加 if-modified-since头行），向原服务器确认缓存对象是否是最新版本&lt;br&gt;
3.扩展 HTTP 代理服务器，支持如下功能：&lt;br&gt;
  a、网站过滤：允许/不允许访问某些网站&lt;br&gt;
  b、用户过滤：支持/不支持某些用户访问外部网站&lt;br&gt;
  c、网站引导：将用户对某个网站的访问引导至一个模拟网站（钓鱼）&lt;br&gt;
&lt;br&gt;
代理服务器，俗称 “翻墙软件” ，允许一个网络终端（一般为客户端）通过这个服务与另一个网络终端（一般为服务器）进行非直接的连接。如图所示，为普通 Web 应用通信方式与采用代理服务器的通信方式的对比。&lt;br&gt;
&lt;img src=&#34;https://github.com/jingyihiter/jingyihiter.github.io/raw/master/css/images/webhttp.png&#34; alt=&#34;&#34; /&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;实现的是多用户代理服务器，实现线程的并行执行。 首先，代理服务器创建 HTTP 代理服务的 TCP 主套接字，通过该主套接字监听等待客户端的连接请求。当客户端连接之后，创建一个子线程，由子线程执行上述一对一的代理过程，服务结束之后子线程终止。与此同时，主线程继续接受下一个客户的代理服务。&lt;br&gt;
&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;实验环境配置-br:7e45868971a7bcd8ef176d27cff9b534&#34;&gt;实验环境配置&lt;br&gt;&lt;/h2&gt;

&lt;p&gt;打开IE（windows）-&amp;gt; 工具 -&amp;gt; Internet选项 -&amp;gt; 连接 -&amp;gt; 局域网设置 -&amp;gt; 代理服务器 &lt;br&gt;
如下设置地址和端口号（端口号和程序中保持一致即可（最好使用较大的，低端口一般被占用））&lt;br&gt;
&lt;img src=&#34;https://github.com/jingyihiter/jingyihiter.github.io/raw/master/css/images/port.png&#34; alt=&#34;&#34; /&gt;&lt;br&gt;
&lt;br&gt;
&lt;strong&gt;基本的HTTP代理服务器，实现简单，不用处理直接转发接收到目的服务器的报文即可。因此不作介绍，主要讲解实现的扩展功能&lt;/strong&gt;。&lt;br&gt;
&lt;br&gt;
&lt;strong&gt;1网站过滤的实现&lt;/strong&gt;&lt;br&gt;
基本思想：通过解析客户端请求的buffer，获取请求的URL，然后设置关键字，再次使用c++中的一个函数&lt;strong&gt;strstr&lt;/strong&gt;，判断关键字是否在其子串中&lt;br&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bool ForbiddenToConnect(char *httpheader)
{
    char * forbiddernUrl = &amp;quot;.edu.cn&amp;quot;; //屏蔽的含有关键字的网址
    if (strstr(httpheader, forbiddernUrl)!=NULL) //是否含有屏蔽的关键字
    {
        return false;
    }
    else return true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;
&lt;strong&gt;2用户过滤的实现&lt;/strong&gt;&lt;br&gt;
基本思想：通过客户端请求，获取请求用户的IP，然后在程序运行时，设置一个IP禁止表，在IP禁止表中存入一些IP地址，在请求之后就去查询是否在IP禁止表中，如果是，则关闭socket即可，等待下一次的请求。&lt;br&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;char client_IP[16];
//设置禁用IP,可以在此添加更多
memcpy(ForbiddenIP[IPnum++], &amp;quot;127.0.0.1&amp;quot;, 16);
//设置访问哪些网站会被重定向到钓鱼网站
memcpy(fishUrl[fishUrlnum++], &amp;quot;http://www.asus.com.cn/&amp;quot;,23);
memcpy(fishUrl[fishUrlnum++],&amp;quot;http://pku.edu.cn/&amp;quot;,18);
while (true) {
    int ff;
    ff = sizeof(acceptAddr);
    acceptSocket = accept(ProxyServer, (SOCKADDR*)&amp;amp;acceptAddr,&amp;amp;(ff));
    printf(&amp;quot;获取用户IP地址：%s\n&amp;quot;,inet_ntoa(acceptAddr.sin_addr));
    memcpy(client_IP, inet_ntoa(acceptAddr.sin_addr),16);//用户IP保存
    //禁用用户IP访问
    if (UserIsForbidden(client_IP))
    {
        printf(&amp;quot;IP被禁用\n&amp;quot;);
        closesocket(acceptSocket);
        //system(&amp;quot;pause&amp;quot;);
        //break;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;
&lt;strong&gt;重点是&lt;/strong&gt;&lt;br&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;acceptSocket = accept(ProxyServer, (SOCKADDR*)&amp;amp;acceptAddr,&amp;amp;(ff));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;
获取请求IP的方法。如果最后一个参数设置的是0，则返回的IP一直是204.204.204.204，显然不是请求的IP地址，因此需要作上述处理，先获取acceptAddr的大小，然后其地址作为accept函数的地址&lt;br&gt;
&lt;br&gt;
&lt;strong&gt;3钓鱼网站的实现（钓鱼网站）&lt;/strong&gt;&lt;br&gt;
基本思想：设置一个钓鱼网站的URL表，如果请求的URL在此URL表中，则丢弃其的请求报文，转成302报文发送，在302报文中定位到钓鱼网站的网址，从而实现访问请求网站自动重定向到钓鱼网站&lt;br&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//网站引导  访问pku.edu.cn  asus.com 重定向到 today.hit.edu.cn
if (GotoFalseWebsite(httpHeader-&amp;gt;url))
{   //302报文 对客户端的请求直接截断重定向到其他页面
        //数据内容主要的就两条：
        //&amp;quot;HTTP/1.1 302 Moved Temporarily&amp;quot;
        //&amp;quot;Location: 路径&amp;quot;
    //生成302报文，直接发送给客户端
    char* pr;  
    int fishing_len = strlen(&amp;quot;HTTP/1.1 302 Moved Temporarily\r\n&amp;quot;); //302报文
    memcpy(FishBuffer, &amp;quot;HTTP/1.1 302 Moved Temporarily\r\n&amp;quot;, fishing_len);
    pr = FishBuffer + fishing_len;
    //重定向到今日哈工大
    fishing_len = strlen(&amp;quot;Location: http://today.hit.edu.cn/\r\n\r\n&amp;quot;);  //定向的网址
    memcpy(pr, &amp;quot;Location: http://today.hit.edu.cn/\r\n\r\n&amp;quot;, fishing_len);
    //将302报文返回给客户端
    ret = send(((ProxyParam*)lpParameter)-&amp;gt;clientSocket, FishBuffer, sizeof(FishBuffer), 0);
    goto error;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;
&lt;strong&gt;4cache的实现&lt;/strong&gt;&lt;br&gt;
基本思想：cache作为代理服务器的缓存管理。首先，客户端请求报文，需要在cache中查询，如果命中，则进行访问目标服务器，缓存是否过期，未过期则直接将缓存的报文转发给客户端,过期则将目标服务器返回的报文进行更新cache；未命中，则直接请求目标服务器，将目标服务器的返回报文更新到cache中，并发送给客户端。&lt;br&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//cache 实现
    if (Have_cache) //请求有缓存
    {
        char cached_buffer[MAXSIZE];//缓存buffer
        ZeroMemory(cached_buffer, MAXSIZE);
        memcpy(cached_buffer, Buffer, recvSize);

        //构造缓存的报文头
        char* pr = cached_buffer + recvSize;
        memcpy(pr, &amp;quot;If-modified-since: &amp;quot;, 19);
        pr += 19;
        int lenth = strlen(Cache[last_cache].last_modified);
        memcpy(pr, Cache[last_cache].last_modified, lenth);
        pr += lenth;
        //将客户端发送的 HTTP 数据报文直接转发给目标服务器
        ret = send(((ProxyParam *)lpParameter)-&amp;gt;serverSocket, cached_buffer, strlen(cached_buffer) + 1, 0);
        //等待目标服务器返回数据
        recvSize = recv(((ProxyParam *)lpParameter)-&amp;gt;serverSocket, cached_buffer, MAXSIZE, 0);
        if (recvSize &amp;lt;= 0) {
            goto error;
        }

        //解析包含缓存信息的HTTP报文头
        CacheBuffer = new char[recvSize + 1];
        ZeroMemory(CacheBuffer, recvSize + 1);
        memcpy(CacheBuffer, cached_buffer, recvSize);
        char last_status[4];//用于记录主机返回的状态字
        char last_modified[30];//用于记录记住返回的页面修改的时间
        ParseCache(CacheBuffer, last_status, last_modified);
        delete CacheBuffer;

        //分析cache的状态字
        if (strcmp(last_status, &amp;quot;304&amp;quot;) == 0) {//没有被修改
            printf(&amp;quot;页面没有修改过,缓存的url为:%s\n&amp;quot;, Cache[last_cache].url);
            //将缓存的数据直接转发给客户端
            ret = send(((ProxyParam*)lpParameter)-&amp;gt;clientSocket, Cache[last_cache].buffer, sizeof(Cache[last_cache].buffer), 0);
            if (ret != SOCKET_ERROR)
            {
                printf(&amp;quot;来自缓存++++++++++++++\n&amp;quot;);
            }
        }
        else if (strcmp(last_status, &amp;quot;200&amp;quot;) == 0) {//已经修改了
            //修改缓存中的内容
            printf(&amp;quot;页面已经被修改过,缓存的url为:%s\n&amp;quot;, Cache[last_cache].url);
            memcpy(Cache[last_cache].buffer, cached_buffer, strlen(cached_buffer));//新的buffer 存在缓存中
            memcpy(Cache[last_cache].last_modified, last_modified, strlen(last_modified)); //修改时间存入缓存

            //将目标服务器返回的数据直接转发给客户端
            ret = send(((ProxyParam*)lpParameter)-&amp;gt;clientSocket, cached_buffer, sizeof(cached_buffer), 0);
            if (ret != SOCKET_ERROR)
            {
                printf(&amp;quot;来自修改过的缓存-----------\n&amp;quot;);
            }
        }
    }
    else //没有缓存过这个页面
    {
        //将客户端发送的 HTTP 数据报文直接转发给目标服务器
        ret = send(((ProxyParam *)lpParameter)-&amp;gt;serverSocket, Buffer, strlen(Buffer) + 1, 0);
        if (ret != SOCKET_ERROR)
        {
            printf(&amp;quot;成功发送给目标服务器的报文buffer \n \n&amp;quot;);
        }
        //等待目标服务器返回数据
        recvSize = recv(((ProxyParam *)lpParameter)-&amp;gt;serverSocket, Buffer, MAXSIZE, 0);
        if (recvSize == SOCKET_ERROR)
        {
            printf(&amp;quot;目标服务器未返回数据\n&amp;quot;);
            goto error;
        }
        //将目标服务器返回的数据直接转发给客户端
        ret = send(((ProxyParam*)lpParameter)-&amp;gt;clientSocket, Buffer, sizeof(Buffer), 0);
        if (ret != SOCKET_ERROR)
        {
            printf(&amp;quot;来自服务器************\n成功发送给客户端的报文(目标服务器返回的)buffer ret = %d \n&amp;quot;, ret);
        }
    }
    //错误处理
error:
    printf(&amp;quot;关闭套接字\n&amp;quot;);
    Sleep(200);
    closesocket(((ProxyParam*)lpParameter)-&amp;gt;clientSocket);
    closesocket(((ProxyParam*)lpParameter)-&amp;gt;serverSocket);
    delete lpParameter;
    _endthreadex(0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;
cache的报文头解析&lt;br&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//*************************
//Method: ParseHttpHead0
//FullName: ParseHttpHead0
//Access: public
//Returns: void
//Qualifier: 解析 TCP 报文中的 HTTP 头部
//Parameter: char *buffer
//Parameter: HttpHeader *httpHeader
//*************************

int ParseHttpHead0(char *buffer, HttpHeader *httpHeader) {
    int flag = 0;//用于表示Cache是否命中，命中为1，不命中为0
    char *p;
    char *ptr;
    const char *delim = &amp;quot;\r\n&amp;quot;;//回车换行符                           
    p = strtok_s(buffer, delim, &amp;amp;ptr);
    if (p[0] == &#39;G&#39;) {  //GET方式
        memcpy(httpHeader-&amp;gt;method, &amp;quot;GET&amp;quot;, 3);
        memcpy(httpHeader-&amp;gt;url, &amp;amp;p[4], strlen(p) - 13);
        printf(&amp;quot;url：%s\n&amp;quot;, httpHeader-&amp;gt;url);//url                                       
        for (int i = 0; i &amp;lt; 1024; i++) {//搜索cache，看当前访问的url是否已经存在cache中了
            if (strcmp(Cache[i].url, httpHeader-&amp;gt;url) == 0) {//说明url在cache中已经存在
                flag = 1;   //只要存在，flag标识变量置为1
                break;
            }
        }
        if (!flag &amp;amp;&amp;amp; cached_number != 1023) {//说明url没有在cache且cache没有满, 把这个url直接存进去
            memcpy(Cache[cached_number].url, &amp;amp;p[4], strlen(p) - 13);
            last_cache = cached_number;
        }
        else if (!flag &amp;amp;&amp;amp; cached_number == 1023) {//说明url没有在cache且cache满了
            //为了简单，替换第一个
            memcpy(Cache[0].url, &amp;amp;p[4], strlen(p) - 13);
            last_cache = 0;
        }
    }
    else if (p[0] == &#39;P&#39;) { //POST方式
        memcpy(httpHeader-&amp;gt;method, &amp;quot;POST&amp;quot;, 4);
        memcpy(httpHeader-&amp;gt;url, &amp;amp;p[5], strlen(p) - 14);
        for (int i = 0; i &amp;lt; 1024; i++) {
            if (strcmp(Cache[i].url, httpHeader-&amp;gt;url) == 0) { //同上
                flag = 1;
                break;
            }
        }
        if (!flag &amp;amp;&amp;amp; cached_number != 1023) {
            memcpy(Cache[cached_number].url, &amp;amp;p[5], strlen(p) - 14);
            last_cache = cached_number;
        }
        else if (!flag &amp;amp;&amp;amp; cached_number == 1023) {
            memcpy(Cache[0].url, &amp;amp;p[4], strlen(p) - 13);
            last_cache = 0;
        }
    }

    p = strtok_s(NULL, delim, &amp;amp;ptr);
    while (p) {
        switch (p[0]) {
        case &#39;H&#39;://HOST
            memcpy(httpHeader-&amp;gt;host, &amp;amp;p[6], strlen(p) - 6);
            if (!flag &amp;amp;&amp;amp; cached_number != 1023) {
                memcpy(Cache[last_cache].host, &amp;amp;p[6], strlen(p) - 6);
                cached_number++;
            }
            else if (!flag &amp;amp;&amp;amp; cached_number == 1023) {
                memcpy(Cache[last_cache].host, &amp;amp;p[6], strlen(p) - 6);
            }
            break;
        case &#39;C&#39;://Cookie
            if (strlen(p) &amp;gt; 8) {
                char header[8];
                ZeroMemory(header, sizeof(header));
                memcpy(header, p, 6);
                if (!strcmp(header, &amp;quot;Cookie&amp;quot;)) {
                    memcpy(httpHeader-&amp;gt;cookie, &amp;amp;p[8], strlen(p) - 8);
                }
            }
            break;
            //case &#39;&#39;:
        default:
            break;
        }
        p = strtok_s(NULL, delim, &amp;amp;ptr);
    }
    return flag;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;
&lt;strong&gt;&lt;a href=&#34;https://github.com/jingyihiter/http_proxy&#34;&gt;重复一遍，源码地址&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>About-me</title>
      <link>https://jingyihiter.github.io/2016/06/30/about-me</link>
      <pubDate>Thu, 30 Jun 2016 23:30:25 +0800</pubDate>
      
      <guid>https://jingyihiter.github.io/2016/06/30/about-me</guid>
      <description>

&lt;h2 id=&#34;education:6083a88ee3411b0d17ce02d738f69d47&#34;&gt;education&lt;/h2&gt;

&lt;p&gt;2010.9~2013.7   湖北省枣阳市第一中学&lt;/p&gt;

&lt;p&gt;2013.9~2017.7   哈尔滨工业大学计算机学院本科生&lt;/p&gt;

&lt;p&gt;2017.9~至今     哈尔滨工业大学计算机学院研究生&lt;/p&gt;

&lt;h2 id=&#34;contact:6083a88ee3411b0d17ce02d738f69d47&#34;&gt;contact&lt;/h2&gt;

&lt;p&gt;Tel-num——18045177508&lt;/p&gt;

&lt;p&gt;Email——18045177508@189.cn&lt;/p&gt;

&lt;p&gt;QQ——920236875&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>https://jingyihiter.github.io/1/01/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jingyihiter.github.io/1/01/01/</guid>
      <description>

&lt;h2 id=&#34;闲聊机器人调研:6ec0b5ab1b904817be52eac14e5c3565&#34;&gt;闲聊机器人调研&lt;/h2&gt;

&lt;p&gt;Q:闲聊机器人现如今主要用了哪些技术？分为哪些模块？&lt;/p&gt;

&lt;h1 id=&#34;1-聊天机器人系统:6ec0b5ab1b904817be52eac14e5c3565&#34;&gt;1、聊天机器人系统&lt;/h1&gt;

&lt;p&gt;这一部分参考(&lt;a href=&#34;http://www.sohu.com/a/56113983_129720&#34;&gt;http://www.sohu.com/a/56113983_129720&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;聊天机器人的系统框架如下图所示，NLP领域主要以文本输入的聊天机器人为主，因此这里的聊天机器人主要以自然语言理解、对话管理和自然语言生成三个模块为主。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6%E5%9B%BE.png&#34; alt=&#34;聊天机器人的系统框架图&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;自然语言理解:6ec0b5ab1b904817be52eac14e5c3565&#34;&gt;&lt;strong&gt;自然语言理解&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;自然语言理解的目的是为聊天任务生成一种语义表示形式。通常来说，聊天机器人系统中的自然语言理解功能包括&lt;strong&gt;用户意图识别、用户情感识别、指代消解、省略恢复、回复确认及拒识判断&lt;/strong&gt;等技术&lt;/p&gt;

&lt;p&gt;1）&lt;strong&gt;用户意图识别&lt;/strong&gt;：用户意图又包括显式意图和隐式意图，显示的意图通常对应一个明确的需求，而隐式意图则较难判断，如用户输入“我的手机用了三年了”，有可能想要换一个手机或者显示其手机性能和质量良好。&lt;/p&gt;

&lt;p&gt;2）&lt;strong&gt;用户情感识别&lt;/strong&gt;：用户情感同样也包含显式和隐式两种，如用户输入“我今天非常高兴”，明确表明了喜悦的情感，而“今天考试刚刚及格”，则不太容易判断用户的情感。&lt;/p&gt;

&lt;p&gt;3）&lt;strong&gt;指代消解和省略恢复&lt;/strong&gt;：在对话过程中，由于人们之间具备聊天主题背景一致性的前提，用户通常使用代词来指代上文中的某个实体或事件，或者干脆省略一部分句子成分。但对于聊天机器人系统来说只有明确了代词指代的成分以及句子中省略的成分，才能正确理解用户的输入，给出合乎上下文语义的回复。因此需要进行代词的消解和省略的恢复。&lt;/p&gt;

&lt;p&gt;4）&lt;strong&gt;回复确认&lt;/strong&gt;：用户意图有时会带有一定的模糊性，这时就需要系统具有主动询问的功能，进而对模糊的意图进行确认，即回复确认。&lt;/p&gt;

&lt;p&gt;5）&lt;strong&gt;拒识判断&lt;/strong&gt;：聊天机器人系统应当具备一定的拒识能力，主动拒绝识别超出自身回复范围之外或者涉及敏感话题的用户输入。&lt;/p&gt;

&lt;h2 id=&#34;对话管理:6ec0b5ab1b904817be52eac14e5c3565&#34;&gt;&lt;strong&gt;对话管理&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;对话管理功能主要协调聊天机器人的各个部分，并维护对话的结构和状态。对话管理功能中涉及到的关键技术主要有&lt;strong&gt;对话行为识别、对话状态识别、对话策略学习及对话奖励&lt;/strong&gt;等。&lt;/p&gt;

&lt;p&gt;1）&lt;strong&gt;对话行为识别&lt;/strong&gt;：对话行为是指预先定义或者动态生成的对话意图的抽象表示形式。分为封闭式和开放式两种，所谓封闭式对话行为，即将对话意图映射到预先定义好的对话行为类别体系。常见于特定领域或特定任务的对话系统，如票务预订、酒店预订等，例如：“我想预订一个标准间”，这句话被识别为Reservation(Standard_room) 的对话行为。相对的，开放式对话行为则没有预先定义好的对话行为类别体系，对话行为动态生成。常见于开放域对话系统，如聊天机器人。例如：“今天心情真好啊”，这句话的对话行为可以通过隐式的主题、N元组、相似句子簇、连续向量等形式表达。&lt;/p&gt;

&lt;p&gt;2）&lt;strong&gt;对话状态识别&lt;/strong&gt;：对话状态与对话的时序及对话行为相关联，在t时刻的对话行为序列即为t时刻的对话状态。因此，对话状态的转移就由前一时刻的对话状态与当前时刻的对话行为决定。&lt;/p&gt;

&lt;p&gt;3）&lt;strong&gt;对话策略学习&lt;/strong&gt;：通常是通过离线的方式，从人-人对话数据中学习对话的行为、状态、流行度等信息，从而作为指导人-机对话的策略。这里流行度通常是指特定模式在语料库中的频度。&lt;/p&gt;

&lt;p&gt;4）&lt;strong&gt;对话奖励&lt;/strong&gt;：对话奖励是对话系统的中间级评价机制，但会影响对话系统的整体评价。常见的对话奖励有槽填充效率和回复流行度等。&lt;/p&gt;

&lt;h2 id=&#34;自然语言生成:6ec0b5ab1b904817be52eac14e5c3565&#34;&gt;自然语言生成&lt;/h2&gt;

&lt;p&gt;自然语言生成通常根据对话管理部分产生的非语言信息，自动生成面向用户的自然语言反馈。近年来，在聊天机器人系统上的对话生成主要涉及&lt;strong&gt;检索式和生成式&lt;/strong&gt;两类技术。&lt;/p&gt;

&lt;p&gt;1）&lt;strong&gt;检索式对话生成技术&lt;/strong&gt;：检索式的代表性技术是在已有的人人对话语料库中通过排序学习技术和深度匹配技术找到适合当前输入的最佳回复。这种方法的局限是仅能以固定的语言模式进行回复，无法实现词语的多样性组合。&lt;/p&gt;

&lt;p&gt;2）&lt;strong&gt;生成式对话生成技术&lt;/strong&gt;：生成式的代表性技术则是从已有的人人对话中学习语言的组合模式，是通过一种类似机器翻译中常用的“编码-解码”的过程去逐字或逐词地生成一个回复，这种回复有可能是从未在语料库中出现的、由聊天机器人自己“创造”出来的句子。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;聊天机器人研究存在的挑战&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;聊天机器人的研究存在的挑战包括：对话上下文建模、对话过程中的知识表示、对话策略学习、聊天机器人智能程度的评价等。&lt;/p&gt;

&lt;p&gt;1）&lt;strong&gt;对话上下文建模&lt;/strong&gt;：聊天是一个有特定背景的连续交互过程，在这一过程中经常出现上下文省略和指代的情况。一句话的意义有时要结合对话上下文或者相关的背景才能确定，而现有的自然语言理解主要基于上下文无关假设，因此对话上下文的建模成为聊天机器人系统的主要挑战之一。&lt;/p&gt;

&lt;p&gt;2）&lt;strong&gt;对话过程中的知识表示&lt;/strong&gt;：知识表示一直就是人工智能领域的重要课题，也是聊天机器人提供信息服务的基础。聊天机器人相关的领域任务可能有复杂的组成，牵涉很多的因素，只有了解这些因素的关系和相关的含义，才能与用户做到真正意义上的交流。&lt;/p&gt;

&lt;p&gt;3）&lt;strong&gt;对话策略学习&lt;/strong&gt;：对话策略涉及很多方面，其中最主要的是对话的主导方式。对话主导方式可以分为用户主导、系统主导和混合主导三种方式。在当前的对话管理研究中，系统应答的目标是自然、友好、积极，在不会发生问题的情况下，让用户尽可能自主，实现对话的混合主导。&lt;/p&gt;

&lt;p&gt;4）&lt;strong&gt;聊天机器人智能程度的评价&lt;/strong&gt;：目前聊天机器人智能程度的评价也是一项挑战。虽然可以采用一些通用的客观评价标准，如回答正确率、任务完成率、对话回合数、对话时间、系统平均响应时间、错误信息率等，对聊天机器人进行评价，评价的基本单元是单轮对话。但是，由于人机对话过程是一个连续的过程，而对不同聊天机器人系统的连续对话的评价仅能保证首句输入的一致性，当对话展开后，不同系统的回复不尽相同，因此不能简单地将连续对话切分成单轮对话去评价，于是设计合理的人工主观评价也许能够成为客观评价标准之外，对聊天机器人系统智能程度评价的重要指标。&lt;/p&gt;

&lt;h1 id=&#34;2-聊天机器人的现有解决方案:6ec0b5ab1b904817be52eac14e5c3565&#34;&gt;2、聊天机器人的现有解决方案&lt;/h1&gt;

&lt;p&gt;闲聊机器人问题的组成：&lt;/p&gt;

&lt;p&gt;2.1、答案生成（选择）&lt;/p&gt;

&lt;p&gt;Solution1: 基于规则的聊天机器人：&lt;/p&gt;

&lt;p&gt;通过人工设定对话场景，并对每个场景写一些针对性的对话模板或规则库，所有问题的答案均是根据已建立的规则库进行规则匹配和推理得到,具有准确性高、知识获取便捷的特点。&lt;/p&gt;

&lt;p&gt;优点：精准性高&lt;/p&gt;

&lt;p&gt;缺点：需要大量人工工作，而且可扩展性差；&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8E%E8%A7%84%E5%88%99%E7%9A%84%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%9B%BE.png&#34; alt=&#34;一个基于规则的聊天机器人的系统结构图&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Solution2: 基于检索的聊天机器人：&lt;/p&gt;

&lt;p&gt;1、预先存储好对话库并建立索引&lt;/p&gt;

&lt;p&gt;2、根据用户问句，在对话库中进行模糊匹配找到最合适的应答内容&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;%E5%9F%BA%E4%BA%8E%E6%A3%80%E7%B4%A2%E7%9A%84%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA.png&#34; alt=&#34;基于检索的微信聊天机器人&#34; /&gt;
Solution3: 基于深度学习的聊天机器人&lt;/p&gt;

&lt;p&gt;根据context来生成对话，如seq2seq+attention框架&lt;/p&gt;

&lt;p&gt;1、Encoder：压缩表示当前用户问题与上下文信息
 2、Decoder：解码出答案
&lt;img src=&#34;%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E7%B3%BB%E7%BB%9F.png&#34; alt=&#34;一个基于深度学习的聊天机器人的系统&#34; /&gt;
3、面临的问题：&lt;/p&gt;

&lt;p&gt;聊天机器人的评价标准&lt;/p&gt;

&lt;p&gt;缺乏标准化的大规模训练数据&lt;/p&gt;

&lt;p&gt;“安全回答”（Safe Response）问题：聊天机器人都用少数非常常见的句子进行应答&lt;/p&gt;

&lt;p&gt;个性信息一致性问题&lt;/p&gt;

&lt;p&gt;2.2、对话状态跟踪&lt;/p&gt;

&lt;p&gt;理解或者捕捉user intention或者goal&lt;/p&gt;

&lt;p&gt;2.3、用户建模&lt;/p&gt;

&lt;p&gt;3.1对于复杂、细致的业务，需要对用户建模，相同的问题，bot给每个人的response是不同的。&lt;/p&gt;

&lt;p&gt;3.2用户建模需要涉及的不仅仅是简单的用户基本信息和用户的一些显式反馈信息，而更重要的是用户的history conversations，这些隐式的反馈信息。&lt;/p&gt;

&lt;p&gt;3.3 对user进行建模，就是做一个个性化的bot，生成的每一个response都有这个user鲜明的特点&lt;/p&gt;

&lt;p&gt;2.4 闲聊机器人的性能评价&lt;/p&gt;

&lt;p&gt;采用机器翻译中的bleu值，  对话的平均轮数，  人工进行评价。其中设计评价机制评分，进行人工评价更有说服力。&lt;/p&gt;

&lt;p&gt;Reference:&lt;/p&gt;

&lt;p&gt;[1] &lt;a href=&#34;http://www.sohu.com/a/110529212_119709&#34;&gt;http://www.sohu.com/a/110529212_119709&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[2] &lt;a href=&#34;http://blog.csdn.net/malefactor/article/details/51901115&#34;&gt;http://blog.csdn.net/malefactor/article/details/51901115&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[3] 王磊,魏勇,邸建勋,杨小琳. 本体聊天机器人的设计与应用[J]. 自动化与信息工程,2016,37(04):13-18&lt;/p&gt;

&lt;h1 id=&#34;3-微软小冰的例子:6ec0b5ab1b904817be52eac14e5c3565&#34;&gt;3、微软小冰的例子&lt;/h1&gt;

&lt;p&gt;参考（&lt;a href=&#34;http://www.ccf.org.cn/sites/weixin/chatbot.pdf&#34;&gt;http://www.ccf.org.cn/sites/weixin/chatbot.pdf&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;小冰作为闲聊机器人，它的聊天引擎主要有：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;底层&lt;/strong&gt;：数据层，包含普通数据，抽取的聊天知识&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;中间层&lt;/strong&gt;：引擎与技术，比如闲聊引擎，问答引擎，Task-completion引擎，基于搜索和基于生成的技术。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;上层&lt;/strong&gt;：用户画像、上下文场景，通过聊天建立用户画像和上下文场景。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;闲聊引擎&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;1）个性化聊天：根据用户不同作不同倾向性的回复，根据用户画像选最优的回复&lt;/p&gt;

&lt;p&gt;2）深度聊天：即针对某些重点话题整理聊天知识，使得聊天内容更加深入和丰富&lt;/p&gt;

&lt;p&gt;3）基于图片的聊天：根据对图片的识别和理解，形成聊天&lt;/p&gt;

&lt;p&gt;4）基于图片标题的聊天：根据图片的内容和对图片标题的描述，生成评论性的聊天&lt;/p&gt;

&lt;h1 id=&#34;4-实现聊天机器人的技术:6ec0b5ab1b904817be52eac14e5c3565&#34;&gt;4、实现聊天机器人的技术&lt;/h1&gt;

&lt;p&gt;搭建一个简单的聊天机器人demo需要的技术&lt;/p&gt;

&lt;h2 id=&#34;4-1-数据集:6ec0b5ab1b904817be52eac14e5c3565&#34;&gt;4.1 数据集&lt;/h2&gt;

&lt;p&gt;对话系统的数据集(参考：&lt;a href=&#34;https://github.com/candlewill/Dialog_Corpus&#34;&gt;https://github.com/candlewill/Dialog_Corpus&lt;/a&gt;)：&lt;/p&gt;

&lt;p&gt;1) &lt;a href=&#34;https://github.com/rustch3n/dgk_lost_conv&#34;&gt;dgk_shooter_min.conv.zip&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;中文电影对白语料，噪音比较大，许多对白问答关系没有对应好&lt;/p&gt;

&lt;p&gt;2) &lt;a href=&#34;https://github.com/kite1988/nus-sms-corpus&#34;&gt;The NUS SMS Corpus&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;包含中文和英文短信息语料，据说是世界最大公开的短消息语料&lt;/p&gt;

&lt;p&gt;3) &lt;a href=&#34;https://github.com/gunthercox/chatterbot-corpus/tree/master/chatterbot_corpus/data&#34;&gt;ChatterBot中文基本聊天语料&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ChatterBot聊天引擎提供的一点基本中文聊天语料，量很少，但质量比较高&lt;/p&gt;

&lt;p&gt;4) &lt;a href=&#34;https://github.com/karthikncode/nlp-datasets&#34;&gt;Datasets for Natural Language Processing&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这是他人收集的自然语言处理相关数据集，主要包含Question Answering，Dialogue Systems， Goal-Oriented Dialogue Systems三部分，都是英文文本。可以使用机器翻译为中文，供中文对话使用&lt;/p&gt;

&lt;p&gt;5) &lt;a href=&#34;https://github.com/rustch3n/dgk_lost_conv/tree/master/results&#34;&gt;小黄鸡&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;据传这就是小黄鸡的语料：xiaohuangji50w_fenciA.conv.zip （已分词） 和 xiaohuangji50w_nofenci.conv.zip （未分词）&lt;/p&gt;

&lt;p&gt;6) &lt;a href=&#34;https://github.com/Samurais/egret-wenda-corpus&#34;&gt;白鹭时代中文问答语料&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;由白鹭时代官方论坛问答板块10,000+ 问题中，选择被标注了“最佳答案”的纪录汇总而成。人工review raw data，给每一个问题，一个可以接受的答案。目前，语料库只包含2907个问答。(备份)&lt;/p&gt;

&lt;p&gt;7) &lt;a href=&#34;https://github.com/Marsan-Ma/chat_corpus&#34;&gt;Chat corpus repository&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;chat corpus collection from various open sources&lt;/p&gt;

&lt;p&gt;包括：开放字幕、英文电影字幕、中文歌词、英文推文&lt;/p&gt;

&lt;p&gt;8) &lt;a href=&#34;https://github.com/Samurais/insuranceqa-corpus-zh&#34;&gt;保险行业QA语料库&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;通过翻译 insuranceQA产生的数据集。train_data含有问题12,889条，数据 141779条，正例：负例 = 1:10； test_data含有问题2,000条，数据 22000条，正例：负例 = 1:10；valid_data含有问题2,000条，数据 22000条，正例：负例 = 1:10&lt;/p&gt;

&lt;h2 id=&#34;4-2-基于规则与检索的聊天机器人:6ec0b5ab1b904817be52eac14e5c3565&#34;&gt;4.2 基于规则与检索的聊天机器人&lt;/h2&gt;

&lt;p&gt;利用开源的搜索引擎做检索(参考：&lt;a href=&#34;https://www.zhihu.com/question/19583321&#34;&gt;https://www.zhihu.com/question/19583321&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;Lucene及其变种&lt;/p&gt;

&lt;p&gt;· Lucene &lt;a href=&#34;https://link.zhihu.com/?target=http%3A//lucene.apache.org/&#34;&gt;http://lucene.apache.org/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;· Solr   &lt;a href=&#34;http://lucene.apache.org/solr/&#34;&gt;http://lucene.apache.org/solr/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;· Elasticsearch &lt;a href=&#34;https://link.zhihu.com/?target=http%3A//www.elasticsearch.org/&#34;&gt;http://www.elasticsearch.org/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Zettair &lt;a href=&#34;https://link.zhihu.com/?target=http%3A//www.seg.rmit.edu.au/zettair/&#34;&gt;http://www.seg.rmit.edu.au/zettair/&lt;/a&gt; Indri &lt;a href=&#34;https://link.zhihu.com/?target=http%3A//www.lemurproject.org/indri/&#34;&gt;http://www.lemurproject.org/indri/&lt;/a&gt; Terrier &lt;a href=&#34;https://link.zhihu.com/?target=http%3A//terrier.org/&#34;&gt;http://terrier.org/&lt;/a&gt; Galago &lt;a href=&#34;https://link.zhihu.com/?target=http%3A//www.galagosearch.org/&#34;&gt;http://www.galagosearch.org/&lt;/a&gt; Zebra &lt;a href=&#34;https://link.zhihu.com/?target=https%3A//www.indexdata.com/zebra&#34;&gt;https://www.indexdata.com/zebra&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Sphinx &lt;a href=&#34;http://sphinxsearch.com/&#34;&gt;http://sphinxsearch.com/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;4-3-基于生成式的聊天机器人:6ec0b5ab1b904817be52eac14e5c3565&#34;&gt;4.3 基于生成式的聊天机器人&lt;/h2&gt;

&lt;p&gt;基于Seq2Seq模型的回复生成：&lt;/p&gt;

&lt;p&gt;传统的seq2seq模型以及针对聊天机器人的各种变种模型&lt;/p&gt;

&lt;p&gt;(深度学习框架Theano,Tensorflow,Torch等)&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>